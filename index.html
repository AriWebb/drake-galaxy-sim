<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milky Way Galaxy Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            display: block;
            user-select: none;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
        }
        
        p {
            margin: 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Milky Way Galaxy Visualization</h1>
        <p>Use mouse to rotate, scroll to zoom, and right-click drag to pan</p>
        <button id="focusEarth">Focus on Earth</button>
        <button id="focusGalaxy">View Entire Galaxy</button>
    </div>
    
    <style>
        button {
            background-color: #0077ff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 5px 5px 0 0;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0055cc;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Galaxy visualization
        let scene, camera, renderer, controls;
        const particleCount = 10000;
        const galaxyRadius = 5000;
        const galaxyHeight = 300;
        const coreRadius = 1000;
        const coreConcentration = 0.5;
        
        // Variables to store Earth's position
        let earthX, earthY, earthZ;
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 1000, 2000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Add controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 100;
            controls.maxDistance = 15000;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            
            // Create stars
            createGalaxy();
            
            // Add window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Add button handlers
            document.getElementById('focusEarth').addEventListener('click', focusOnEarth);
            document.getElementById('focusGalaxy').addEventListener('click', focusOnGalaxy);
            
            // Start animation loop
            animate();
        }
        
        // Function to focus camera on Earth
        function focusOnEarth() {
            // Create a position slightly offset from Earth for better viewing
            const offset = new THREE.Vector3(earthX, earthY + 50, earthZ + 200);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3();
            controls.target.copy(startTarget);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, offset, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(earthX, earthY, earthZ), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Function to focus on the entire galaxy
        function focusOnGalaxy() {
            // Create a position to view the entire galaxy
            const galaxyViewPosition = new THREE.Vector3(0, 1000, 5000);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3().copy(controls.target);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, galaxyViewPosition, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(0, 0, 0), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Easing function for smoother camera animation
        function easeOutQuad(t) {
            return t * (2 - t);
        }
        
        // Create the galaxy with spiral arms
        function createGalaxy() {
            const starColors = [
                0xFFFFFF, // white
                0xFFFF00, // yellow
                0xFFD700, // gold
                0xFF8C00, // orange
                0xFF4500, // red-orange
                0x00BFFF, // light blue
                0x1E90FF  // blue
            ];
            
            // Create geometry for all stars
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const color = new THREE.Color();
            
            // Define spiral arms
            const spiralArms = 5;
            const armSpread = 0.5;
            
            // Earth's position in the Milky Way
            // Solar system is about 26,000 light years (8 kpc) from the galactic center
            // We'll place it in one of the spiral arms
            const earthArmIndex = 2; // Choosing the 3rd arm (0-indexed)
            const earthDistanceFromCenter = 2600; // Scaled distance
            const earthSpiralFactor = 4.0;
            const earthAngle = (Math.PI * 2 * earthArmIndex / spiralArms) + 0.2; // Adding a bit of offset
            const earthTheta = earthAngle + (earthDistanceFromCenter / galaxyRadius) * earthSpiralFactor;
            
            // Calculate Earth's position (assign to global variables)
            earthX = earthDistanceFromCenter * Math.cos(earthTheta);
            earthZ = earthDistanceFromCenter * Math.sin(earthTheta);
            earthY = 0; // Roughly on the galactic plane
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Determine if star is in core or in spiral arms
                const isCore = Math.random() < coreConcentration;
                
                let x, y, z;
                
                if (isCore) {
                    // Stars in galactic core - dense center
                    const r = Math.random() * coreRadius;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 0.5 * Math.PI;
                    
                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);
                    
                    // Core stars are whiter/bluer
                    color.set(starColors[Math.floor(Math.random() * 2)]);
                } else {
                    // Stars in spiral arms
                    const arm = Math.floor(Math.random() * spiralArms);
                    const angle = (Math.PI * 2 * arm / spiralArms) + (Math.random() * armSpread);
                    const distance = coreRadius + Math.random() * (galaxyRadius - coreRadius);
                    const spiralFactor = 4.0; // controls tightness of the spiral
                    
                    const theta = angle + (distance / galaxyRadius) * spiralFactor;
                    
                    x = distance * Math.cos(theta);
                    z = distance * Math.sin(theta);
                    
                    // Add some randomness to spiral
                    x += (Math.random() - 0.5) * distance * 0.3;
                    z += (Math.random() - 0.5) * distance * 0.3;
                    
                    // Y-position (height) drops off with distance from center
                    const heightFactor = 1 - (distance / galaxyRadius) * 0.8;
                    y = (Math.random() - 0.5) * galaxyHeight * heightFactor;
                    
                    // Different colors based on position
                    const colorIndex = Math.min(Math.floor((distance / galaxyRadius) * starColors.length), starColors.length - 1);
                    color.set(starColors[colorIndex]);
                }
                
                // Set position
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                // Set color
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            // Add attributes to geometry
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create point material
            const material = new THREE.PointsMaterial({
                size: 4,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            // Create the particle system
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Add a reference point for the galactic center
            const centerGeometry = new THREE.SphereGeometry(50, 32, 32);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            scene.add(centerSphere);
            
            // Add Earth (Solar System)
            const earthGeometry = new THREE.SphereGeometry(30, 32, 32);
            const earthMaterial = new THREE.MeshBasicMaterial({
                color: 0x0077ff, // Blue
                transparent: true,
                opacity: 0.9
            });
            const earthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
            earthSphere.position.set(earthX, earthY, earthZ);
            scene.add(earthSphere);
            
            // Add a label for Earth
            createEarthLabel(earthX, earthY, earthZ);
            
            // Add a helper line to Earth from the center
            const earthLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(earthX, earthY, earthZ)
            ]);
            const earthLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0088ff,
                transparent: true,
                opacity: 0.5
            });
            const earthLine = new THREE.Line(earthLineGeometry, earthLineMaterial);
            scene.add(earthLine);
        }
        
        // Function to create a text label for Earth
        function createEarthLabel(x, y, z) {
            // Create a div for the label
            const earthLabelDiv = document.createElement('div');
            earthLabelDiv.className = 'label';
            earthLabelDiv.textContent = 'Earth';
            earthLabelDiv.style.color = '#ffffff';
            earthLabelDiv.style.position = 'absolute';
            earthLabelDiv.style.backgroundColor = 'rgba(0,0,0,0.6)';
            earthLabelDiv.style.padding = '2px 6px';
            earthLabelDiv.style.borderRadius = '3px';
            earthLabelDiv.style.pointerEvents = 'none';
            earthLabelDiv.style.zIndex = '10';
            document.body.appendChild(earthLabelDiv);
            
            // Update the label position in the animation loop
            const earthPosition = new THREE.Vector3(x, y, z);
            const earthVector = new THREE.Vector3();
            
            // Add to the animation function to update position
            const originalAnimate = animate;
            animate = function() {
                // Call the original animate function
                originalAnimate();
                
                // Update label position
                earthVector.copy(earthPosition);
                earthVector.project(camera);
                
                const x = (earthVector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(earthVector.y * 0.5) + 0.5) * window.innerHeight;
                
                earthLabelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                
                // Hide label if Earth is behind the camera
                if (earthVector.z > 1) {
                    earthLabelDiv.style.display = 'none';
                } else {
                    earthLabelDiv.style.display = 'block';
                }
            };
        }
        
        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // required if controls.enableDamping = true
            renderer.render(scene, camera);
        }
        
        // Start the visualization
        init();
    </script>
</body>
</html>