<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milky Way Galaxy Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            display: block;
            user-select: none;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
        }
        
        p {
            margin: 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Milky Way Galaxy Visualization</h1>
        <p>Use mouse to rotate, scroll to zoom, and right-click drag to pan</p>
        <button id="focusEarth">Focus on Earth</button>
        <button id="focusGalaxy">View Entire Galaxy</button>
    </div>
    
    
    <div id="drake-equation">
        <h2>Drake Equation Calculator</h2>
        <p>Adjust parameters to calculate potential civilizations in our galaxy</p>
        
        <div class="slider-container">
            <label for="R">R* = Average rate of star formation (stars/year)</label>
            <input type="range" id="R" min="1" max="20" value="7" step="0.1">
            <span id="R-value">7</span>
        </div>
        
        <div class="slider-container">
            <label for="fp">fp = Fraction of stars with planets</label>
            <input type="range" id="fp" min="0" max="1" value="0.5" step="0.01">
            <span id="fp-value">0.5</span>
        </div>
        
        <div class="slider-container">
            <label for="ne">ne = Average habitable planets per star</label>
            <input type="range" id="ne" min="0" max="5" value="2" step="0.1">
            <span id="ne-value">2</span>
        </div>
        
        <div class="slider-container">
            <label for="fl">fl = Fraction of habitable planets with life</label>
            <input type="range" id="fl" min="0" max="1" value="0.33" step="0.01">
            <span id="fl-value">0.33</span>
        </div>
        
        <div class="slider-container">
            <label for="fi">fi = Fraction of life that develops intelligence</label>
            <input type="range" id="fi" min="0" max="1" value="0.1" step="0.01">
            <span id="fi-value">0.1</span>
        </div>
        
        <div class="slider-container">
            <label for="fc">fc = Fraction of intelligence that develops detectable technology</label>
            <input type="range" id="fc" min="0" max="1" value="0.1" step="0.01">
            <span id="fc-value">0.1</span>
        </div>
        
        <div class="slider-container">
            <label for="L">L = Longevity of detectable civilizations (years)</label>
            <input type="range" id="L" min="1" max="10000" value="1000" step="1">
            <span id="L-value">1000</span>
        </div>
        
        <div id="result">
            <p>N = <span id="N-value">0</span> civilizations in our galaxy</p>
        </div>
        
        <button id="generate-planets">Generate Civilizations</button>
        
        <div class="time-control">
            <label for="time-slider">Time: <span id="time-value">0</span></label>
            <input type="range" id="time-slider" min="0" max="1000" value="0" step="1">
            <div class="metrics">
                <div>Earth Encounters: <span id="earth-encounters">0</span></div>
                <div id="top-conqueror">No conquests yet</div>
            </div>
            <div class="time-buttons">
                <button id="play-pause">Play</button>
                <button id="reset-time">Reset</button>
            </div>
        </div>
    </div>
    
    
    <style>
        button {
            background-color: #0077ff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 5px 5px 0 0;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0055cc;
        }
        
        #drake-equation {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
            font-family: Arial, sans-serif;
        }
        
        h2 {
            margin-top: 0;
            font-size: 1.2em;
        }
        
        .slider-container {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 80%;
            margin-right: 10px;
        }
        
        #result {
            margin: 15px 0;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        #generate-planets {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            font-size: 1em;
            background-color: #4CAF50;
        }
        
        #generate-planets:hover {
            background-color: #388E3C;
        }
        
        .time-control {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .time-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        
        #time-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        #play-pause, #reset-time {
            flex: 1;
        }
        
        .metrics {
            margin: 10px 0;
            color: white;
            font-size: 0.9em;
        }
        .metrics div {
            margin: 5px 0;
        }
        #top-conqueror {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-weight: bold;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Galaxy visualization
        let scene, camera, renderer, controls;
        const particleCount = 10000;
        const galaxyRadius = 5000;
        const galaxyHeight = 300;
        const coreRadius = 1000;
        const coreConcentration = 0.5;
        
        // Variables to store Earth's position
        let earthX, earthY, earthZ;
        
        // Variables for Drake Equation
        let civilizationPlanets = [];
        let drakeN = 0;
        
        // Variables for time simulation
        let timeValue = 0;
        let isPlaying = false;
        let animationId = null;
        let lastUpdateTime = 0;
        const TIME_SPEED = 3.0; // Time units per second (increased for faster playback)
        
        // Add these variables at the top level with other global variables
        let earthEncounters = 0;
        let civilizationConquests = new Map(); // Track conquests for each civilization
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 1000, 2000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Add controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 100;
            controls.maxDistance = 15000;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            
            // Create stars
            createGalaxy();
            
            // Add window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Add button handlers
            document.getElementById('focusEarth').addEventListener('click', focusOnEarth);
            document.getElementById('focusGalaxy').addEventListener('click', focusOnGalaxy);
            document.getElementById('generate-planets').addEventListener('click', generateCivilizations);
            
            // Add Drake equation slider handlers
            setupDrakeEquation();
            
            // Add time slider handlers
            setupTimeControls();
            
            // Start animation loop
            animate();
        }
        
        // Setup Drake Equation sliders and calculation
        function setupDrakeEquation() {
            // Get all sliders
            const sliders = ['R', 'fp', 'ne', 'fl', 'fi', 'fc', 'L'];
            
            // Add event listeners to update values and recalculate N
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(`${id}-value`);
                
                // Set initial value
                valueSpan.textContent = slider.value;
                
                // Add change event listener
                slider.addEventListener('input', function() {
                    valueSpan.textContent = this.value;
                    calculateDrakeEquation();
                });
            });
            
            // Initial calculation
            calculateDrakeEquation();
        }
        
        // Calculate Drake Equation: N = R* × fp × ne × fl × fi × fc × L
        function calculateDrakeEquation() {
            const R = parseFloat(document.getElementById('R').value);
            const fp = parseFloat(document.getElementById('fp').value);
            const ne = parseFloat(document.getElementById('ne').value);
            const fl = parseFloat(document.getElementById('fl').value);
            const fi = parseFloat(document.getElementById('fi').value);
            const fc = parseFloat(document.getElementById('fc').value);
            const L = parseFloat(document.getElementById('L').value);
            
            // Calculate N
            drakeN = R * fp * ne * fl * fi * fc * L;
            
            // Update display
            document.getElementById('N-value').textContent = Math.round(drakeN);
        }
        
        // Generate civilizations based on Drake equation result
        function generateCivilizations() {
            // Reset metrics when generating new civilizations
            earthEncounters = 0;
            civilizationConquests.clear();
            
            // Remove any existing civilization planets
            removeCivilizations();
            
            // Calculate how many planets to generate
            let numPlanets = Math.round(drakeN);
            
            // Cap the number of planets to avoid performance issues
            const maxPlanets = 1000;
            const scaleFactor = numPlanets > maxPlanets ? numPlanets / maxPlanets : 1;
            numPlanets = Math.min(numPlanets, maxPlanets);
            
            if (numPlanets <= 0) {
                alert('Based on current parameters, there are no detectable civilizations in the galaxy.');
                return;
            }
            
            // Create a group for civilization planets
            const civilizationsGroup = new THREE.Group();
            civilizationsGroup.userData = { isCivilizationsGroup: true };
            scene.add(civilizationsGroup);
            
            // Generate random planets throughout the galaxy
            for (let i = 0; i < numPlanets; i++) {
                // Determine if planet is in core or in spiral arms (similar logic as stars)
                const isCore = Math.random() < 0.1; // Less likely in core
                
                let x, y, z;
                
                if (isCore) {
                    // Planets in galactic core
                    const r = Math.random() * coreRadius * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 0.3 * Math.PI;
                    
                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);
                } else {
                    // Planets in spiral arms
                    const arm = Math.floor(Math.random() * 5); // 5 spiral arms
                    const angle = (Math.PI * 2 * arm / 5) + (Math.random() * 0.5);
                    const distance = coreRadius + Math.random() * (galaxyRadius - coreRadius) * 0.9;
                    const spiralFactor = 4.0;
                    
                    const theta = angle + (distance / galaxyRadius) * spiralFactor;
                    
                    x = distance * Math.cos(theta);
                    z = distance * Math.sin(theta);
                    
                    // Add some randomness to spiral
                    x += (Math.random() - 0.5) * distance * 0.2;
                    z += (Math.random() - 0.5) * distance * 0.2;
                    
                    // Y-position (height) drops off with distance from center
                    const heightFactor = 1 - (distance / galaxyRadius) * 0.8;
                    y = (Math.random() - 0.5) * galaxyHeight * heightFactor * 0.5;
                }
                
                // Create the planet
                const baseRadius = 15 + Math.random() * 15;
                const planetGeometry = new THREE.SphereGeometry(baseRadius, 16, 16);
                
                // Choose a fully random color for each civilization
                const hue = Math.random(); // Random hue across the full spectrum
                const saturation = 0.7 + Math.random() * 0.3; // High saturation
                const lightness = 0.4 + Math.random() * 0.3; // Medium to bright
                const planetColor = new THREE.Color().setHSL(hue, saturation, lightness);
                
                const planetMaterial = new THREE.MeshBasicMaterial({
                    color: planetColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(x, y, z);
              
                // Calculate expansion/tech rate with the same logic as before
                const expansionRate = Math.random() < 0.3 ? 
                    0.5 + Math.random() * 2 :  // 30% chance of slow expansion (0.5-2.5)
                    Math.random() < 0.6 ? 
                        3 + Math.random() * 7 :  // 42% chance of medium expansion (3-10)
                        10 + Math.random() * 15;  // 28% chance of fast expansion (10-25)


                planet.userData = {
                    initialScale: 1,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 0.5,
                    expansionStart: Math.random() * 100,
                    expansionRate: expansionRate,
                    baseRadius: baseRadius,
                    originalColor: {
                        h: hue,
                        s: saturation,
                        l: lightness
                    },
                    techAdvancementRate: Math.random(),
                    aggressivenessFactor: Math.random(),
                    civilizationId: `civ_${Math.random().toString(36).substr(2, 9)}`,
                    conqueredCivs: new Set(),
                    encounteredEarth: false
                };
                
                civilizationConquests.set(planet.userData.civilizationId, {
                    conqueredCivs: new Set(),
                    color: `hsl(${hue * 360}, ${saturation * 100}%, ${lightness * 100}%)`
                });
                
                civilizationsGroup.add(planet);
                civilizationPlanets.push(planet);
            }
            
            // Update info about scaling
            if (scaleFactor > 1) {
                alert(`Showing ${numPlanets} of approximately ${Math.round(drakeN)} civilizations to maintain performance.`);
            }
            
            updateMetricsDisplay();
        }
        
        // Remove all civilization planets
        function removeCivilizations() {
            // Remove each planet from its parent and dispose resources
            for (let planet of civilizationPlanets) {
                // Also remove influence spheres
                if (planet.userData && planet.userData.influenceSphere) {
                    scene.remove(planet.userData.influenceSphere);
                    if (planet.userData.influenceSphere.geometry) {
                        planet.userData.influenceSphere.geometry.dispose();
                    }
                    if (planet.userData.influenceSphere.material) {
                        planet.userData.influenceSphere.material.dispose();
                    }
                }
                
                // Remove planet
                if (planet.parent) planet.parent.remove(planet);
                if (planet.geometry) planet.geometry.dispose();
                if (planet.material) planet.material.dispose();
            }
            
            // Find and remove any civilization groups from the scene
            scene.children.forEach(child => {
                if (child.isGroup && child.userData && child.userData.isCivilizationsGroup) {
                    scene.remove(child);
                }
            });
            
            // Clear the array
            civilizationPlanets = [];
            
            // Reset time
            timeValue = 0;
            document.getElementById('time-slider').value = 0;
            document.getElementById('time-value').textContent = '0';
            isPlaying = false;
            document.getElementById('play-pause').textContent = 'Play';
            cancelAnimationFrame(animationId);
        }
        
        // Function to focus camera on Earth
        function focusOnEarth() {
            // Create a position slightly offset from Earth for better viewing
            const offset = new THREE.Vector3(earthX, earthY + 50, earthZ + 200);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3();
            controls.target.copy(startTarget);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, offset, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(earthX, earthY, earthZ), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Function to focus on the entire galaxy
        function focusOnGalaxy() {
            // Create a position to view the entire galaxy
            const galaxyViewPosition = new THREE.Vector3(0, 1000, 5000);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3().copy(controls.target);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, galaxyViewPosition, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(0, 0, 0), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Easing function for smoother camera animation
        function easeOutQuad(t) {
            return t * (2 - t);
        }
        
        // Create the galaxy with spiral arms
        function createGalaxy() {
            const starColors = [
                0xFFFFFF, // white
                0xFFFF00, // yellow
                0xFFD700, // gold
                0xFF8C00, // orange
                0xFF4500, // red-orange
                0x00BFFF, // light blue
                0x1E90FF  // blue
            ];
            
            // Create geometry for all stars
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const color = new THREE.Color();
            
            // Define spiral arms
            const spiralArms = 5;
            const armSpread = 0.5;
            
            // Earth's position in the Milky Way
            // Solar system is about 26,000 light years (8 kpc) from the galactic center
            // We'll place it in one of the spiral arms
            const earthArmIndex = 2; // Choosing the 3rd arm (0-indexed)
            const earthDistanceFromCenter = 2600; // Scaled distance
            const earthSpiralFactor = 4.0;
            const earthAngle = (Math.PI * 2 * earthArmIndex / spiralArms) + 0.2; // Adding a bit of offset
            const earthTheta = earthAngle + (earthDistanceFromCenter / galaxyRadius) * earthSpiralFactor;
            
            // Calculate Earth's position (assign to global variables)
            earthX = earthDistanceFromCenter * Math.cos(earthTheta);
            earthZ = earthDistanceFromCenter * Math.sin(earthTheta);
            earthY = 0; // Roughly on the galactic plane
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Determine if star is in core or in spiral arms
                const isCore = Math.random() < coreConcentration;
                
                let x, y, z;
                
                if (isCore) {
                    // Stars in galactic core - dense center
                    const r = Math.random() * coreRadius;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 0.5 * Math.PI;
                    
                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);
                    
                    // Core stars are whiter/bluer
                    color.set(starColors[Math.floor(Math.random() * 2)]);
                } else {
                    // Stars in spiral arms
                    const arm = Math.floor(Math.random() * spiralArms);
                    const angle = (Math.PI * 2 * arm / spiralArms) + (Math.random() * armSpread);
                    const distance = coreRadius + Math.random() * (galaxyRadius - coreRadius);
                    const spiralFactor = 4.0; // controls tightness of the spiral
                    
                    const theta = angle + (distance / galaxyRadius) * spiralFactor;
                    
                    x = distance * Math.cos(theta);
                    z = distance * Math.sin(theta);
                    
                    // Add some randomness to spiral
                    x += (Math.random() - 0.5) * distance * 0.3;
                    z += (Math.random() - 0.5) * distance * 0.3;
                    
                    // Y-position (height) drops off with distance from center
                    const heightFactor = 1 - (distance / galaxyRadius) * 0.8;
                    y = (Math.random() - 0.5) * galaxyHeight * heightFactor;
                    
                    // Different colors based on position
                    const colorIndex = Math.min(Math.floor((distance / galaxyRadius) * starColors.length), starColors.length - 1);
                    color.set(starColors[colorIndex]);
                }
                
                // Set position
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                // Set color
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            // Add attributes to geometry
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create point material
            const material = new THREE.PointsMaterial({
                size: 4,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            // Create the particle system
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Add a reference point for the galactic center
            const centerGeometry = new THREE.SphereGeometry(50, 32, 32);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            scene.add(centerSphere);
            
            // Add Earth (Solar System)
            const earthGeometry = new THREE.SphereGeometry(30, 32, 32);
            const earthMaterial = new THREE.MeshBasicMaterial({
                color: 0x0077ff, // Blue
                transparent: true,
                opacity: 0.9
            });
            const earthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
            earthSphere.position.set(earthX, earthY, earthZ);
            scene.add(earthSphere);
            
            // Add a label for Earth
            createEarthLabel(earthX, earthY, earthZ);
            
            // Add a helper line to Earth from the center
            const earthLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(earthX, earthY, earthZ)
            ]);
            const earthLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0088ff,
                transparent: true,
                opacity: 0.5
            });
            const earthLine = new THREE.Line(earthLineGeometry, earthLineMaterial);
            scene.add(earthLine);
        }
        
        // Function to create a text label for Earth
        function createEarthLabel(x, y, z) {
            // Create a div for the label
            const earthLabelDiv = document.createElement('div');
            earthLabelDiv.className = 'label';
            earthLabelDiv.textContent = 'Earth';
            earthLabelDiv.style.color = '#ffffff';
            earthLabelDiv.style.position = 'absolute';
            earthLabelDiv.style.backgroundColor = 'rgba(0,0,0,0.6)';
            earthLabelDiv.style.padding = '2px 6px';
            earthLabelDiv.style.borderRadius = '3px';
            earthLabelDiv.style.pointerEvents = 'none';
            earthLabelDiv.style.zIndex = '10';
            document.body.appendChild(earthLabelDiv);
            
            // Update the label position in the animation loop
            const earthPosition = new THREE.Vector3(x, y, z);
            const earthVector = new THREE.Vector3();
            
            // Add to the animation function to update position
            const originalAnimate = animate;
            animate = function() {
                // Call the original animate function
                originalAnimate();
                
                // Update label position
                earthVector.copy(earthPosition);
                earthVector.project(camera);
                
                const x = (earthVector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(earthVector.y * 0.5) + 0.5) * window.innerHeight;
                
                earthLabelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                
                // Hide label if Earth is behind the camera
                if (earthVector.z > 1) {
                    earthLabelDiv.style.display = 'none';
                } else {
                    earthLabelDiv.style.display = 'block';
                }
            };
        }
        
        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Setup time controls
        function setupTimeControls() {
            const timeSlider = document.getElementById('time-slider');
            const timeValueDisplay = document.getElementById('time-value');
            const playPauseButton = document.getElementById('play-pause');
            const resetButton = document.getElementById('reset-time');
            
            // Set initial values
            timeValueDisplay.textContent = timeValue;
            
            // Time slider event
            timeSlider.addEventListener('input', function() {
                timeValue = parseFloat(this.value);
                timeValueDisplay.textContent = timeValue;
                updateSphereExpansion();
            });
            
            // Play/Pause button
            playPauseButton.addEventListener('click', function() {
                togglePlayPause();
            });
            
            // Reset button
            resetButton.addEventListener('click', function() {
                resetSimulation();
            });
        }
        
        // Add separate functions to handle play/pause toggle
        function togglePlayPause() {
            isPlaying = !isPlaying;
            const playPauseButton = document.getElementById('play-pause');
            playPauseButton.textContent = isPlaying ? 'Pause' : 'Play';
            
            if (isPlaying) {
                lastUpdateTime = Date.now() * 0.001; // Reset the last update time
                if (timeValue === 0) {
                    window.hasReset = true; // Ensure we don't reset when starting from 0
                }
                animateTime();
            } else {
                if (animationId !== null) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }
        
        // Update the animateTime function
        function animateTime() {
            const currentTime = Date.now() * 0.001;
            const deltaTime = currentTime - lastUpdateTime;
            lastUpdateTime = currentTime;
            
            // Update time value
            const maxTime = parseFloat(document.getElementById('time-slider').max);
            timeValue = Math.min(maxTime, timeValue + deltaTime * TIME_SPEED);
            
            // Update UI
            document.getElementById('time-slider').value = timeValue;
            document.getElementById('time-value').textContent = Math.round(timeValue);
            
            // Update spheres of influence
            updateSphereExpansion();
            
            // If we've reached the max, stop playing
            if (timeValue >= maxTime) {
                isPlaying = false;
                document.getElementById('play-pause').textContent = 'Play';
                animationId = null;
            } else if (isPlaying) {
                animationId = requestAnimationFrame(animateTime);
            }
        }
        
        // Update the resetSimulation function
        function resetSimulation() {
            // First cancel any ongoing animation
            if (animationId !== null) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Reset time
            timeValue = 0;
            document.getElementById('time-slider').value = timeValue;
            document.getElementById('time-value').textContent = timeValue;
            
            // Reset play state
            isPlaying = false;
            document.getElementById('play-pause').textContent = 'Play';
            lastUpdateTime = Date.now() * 0.001; // Reset the last update time
            window.hasReset = true; // Set the reset flag

            // Reset metrics
            earthEncounters = 0;
            civilizationConquests.clear();

            // Reset all civilizations
            civilizationPlanets.forEach(planet => {
                // Reset Earth encounter flag
                planet.userData.encounteredEarth = false;
                
                // Reset conquest count
                planet.userData.conquests = 0;
                
                // Reset color to original
                planet.material.color.setHSL(
                    planet.userData.originalColor.h,
                    planet.userData.originalColor.s,
                    planet.userData.originalColor.l
                );

                // Reset influence sphere
                if (planet.userData.influenceSphere) {
                    planet.userData.influenceSphere.material.color.copy(planet.material.color);
                    planet.userData.influenceSphere.scale.set(
                        planet.userData.baseRadius,
                        planet.userData.baseRadius,
                        planet.userData.baseRadius
                    );
                }

                // Clear interaction history
                if (planet.userData.interactions) {
                    planet.userData.interactions.clear();
                }

                // Clear conquered civs set
                planet.userData.conqueredCivs = new Set();
                
                // Reset conquest tracking in the Map
                civilizationConquests.set(planet.userData.civilizationId, {
                    conqueredCivs: new Set(),
                    color: `hsl(${planet.userData.originalColor.h * 360}, 
                              ${planet.userData.originalColor.s * 100}%, 
                              ${planet.userData.originalColor.l * 100}%)`
                });
            });

            // Update metrics display
            updateMetricsDisplay();
        }
        
        // Update sphere expansion based on time
        function updateSphereExpansion() {
            if (timeValue === 0) {
                // Only reset if we haven't already reset
                if (!window.hasReset) {
                    resetSimulation();
                    window.hasReset = true;
                }
            } else {
                window.hasReset = false;
            }

            for (let i = 0; i < civilizationPlanets.length; i++) {
                const planetA = civilizationPlanets[i];
                const timeSinceStartA = Math.max(0, timeValue - planetA.userData.expansionStart);
                const sphereRadiusA = planetA.userData.baseRadius + (timeSinceStartA * planetA.userData.expansionRate);

                // Check for Earth intersection
                const distanceToEarth = planetA.position.distanceTo(new THREE.Vector3(earthX, earthY, earthZ));
                if (distanceToEarth < (sphereRadiusA + 30) && !planetA.userData.encounteredEarth) {
                    earthEncounters++;
                    planetA.userData.encounteredEarth = true;
                    updateMetricsDisplay();
                }

                for (let j = 0; j < civilizationPlanets.length; j++) {
                    if (i === j) continue;
                    
                    const planetB = civilizationPlanets[j];
                    const distance = planetA.position.distanceTo(planetB.position);

                    // Check for sphere intersection with planet
                    if (distance < (sphereRadiusA + planetB.userData.baseRadius)) {
                        // Check for overwhelming superiority conditions
                        const aHighlyAggressiveAndAdvanced = 
                            planetA.userData.aggressivenessFactor >= 0.9 && 
                            planetA.userData.techAdvancementRate >= planetB.userData.techAdvancementRate * 2;
                        
                        if (aHighlyAggressiveAndAdvanced) {
                            // A dominates through superior tech and high aggression
                            applyDominantColor(planetA, planetB, 1);
                            planetA.userData.conqueredCivs.add(planetB.userData.civilizationId);
                            planetB.userData.conqueredCivs.forEach(civ => {
                                planetA.userData.conqueredCivs.add(civ);
                            });
                            civilizationConquests.get(planetA.userData.civilizationId).conqueredCivs = 
                                new Set([...planetA.userData.conqueredCivs]);
                            updateMetricsDisplay();
                        }
                    }
                }

                updateSphereOfInfluence(planetA, sphereRadiusA);
            }
        }

        // Calculate civilization strength based on tech and aggression
        function calculateCivilizationStrength(planetA, planetB) {
            const techA = planetA.userData.techAdvancementRate;
            const aggressionA = planetA.userData.aggressivenessFactor;
            const techB = planetB.userData.techAdvancementRate;
            
            // Check for highly aggressive civilizations with superior technology
            if (aggressionA >= 0.9 && techA >= techB * 2) {
                return 1; // Automatic win for A
            }
            
            // Default strength calculation if special condition isn't met
            return (techA * 0.6) + (aggressionA * 0.4);
        }

        // Update the applyDominantColor function to check if influence spheres exist
        function applyDominantColor(dominant, subordinate, dominantStrength) {
            // Get the original colors
            const dominantColor = dominant.userData.originalColor;
            const subordinateColor = subordinate.userData.originalColor;
            
            // Calculate influence based on strength (stronger = less influence from subordinate)
            const dominantInfluence = 0.7 + (dominantStrength * 0.3); // 0.7-1.0 range
            const subordinateInfluence = 1 - dominantInfluence;
            
            // Mix the colors
            const newHue = (dominantColor.h * dominantInfluence) + (subordinateColor.h * subordinateInfluence);
            const newSat = (dominantColor.s * dominantInfluence) + (subordinateColor.s * subordinateInfluence);
            const newLight = (dominantColor.l * dominantInfluence) + (subordinateColor.l * subordinateInfluence);
            
            // Apply the new color to both civilizations
            dominant.material.color.setHSL(newHue, newSat, newLight);
            subordinate.material.color.setHSL(newHue, newSat, newLight);
            
            // Update influence spheres if they exist
            if (dominant.userData.influenceSphere) {
                dominant.userData.influenceSphere.material.color.copy(dominant.material.color);
            }
            if (subordinate.userData.influenceSphere) {
                subordinate.userData.influenceSphere.material.color.copy(subordinate.material.color);
            }
            
            // Update the conquest data color
            civilizationConquests.get(dominant.userData.civilizationId).color = 
                `hsl(${newHue * 360}, ${newSat * 100}%, ${newLight * 100}%)`;
        }

        // Update the mergeCivilizations function similarly
        function mergeCivilizations(civA, civB) {
            // Average the colors
            const colorA = civA.userData.originalColor;
            const colorB = civB.userData.originalColor;
            
            const newHue = (colorA.h + colorB.h) / 2;
            const newSat = (colorA.s + colorB.s) / 2;
            const newLight = (colorA.l + colorB.l) / 2;
            
            // Apply the merged color to both civilizations
            civA.material.color.setHSL(newHue, newSat, newLight);
            civB.material.color.setHSL(newHue, newSat, newLight);
            
            // Update influence spheres if they exist
            if (civA.userData.influenceSphere) {
                civA.userData.influenceSphere.material.color.copy(civA.material.color);
            }
            if (civB.userData.influenceSphere) {
                civB.userData.influenceSphere.material.color.copy(civB.material.color);
            }
            
            // Update the conquest data colors
            const newColorString = `hsl(${newHue * 360}, ${newSat * 100}%, ${newLight * 100}%)`;
            civilizationConquests.get(civA.userData.civilizationId).color = newColorString;
            civilizationConquests.get(civB.userData.civilizationId).color = newColorString;
        }
        
        // Update the updateSphereOfInfluence function to ensure proper color initialization
        function updateSphereOfInfluence(planet, radius) {
            // Get or create the influence sphere
            if (!planet.userData.influenceSphere) {
                const sphereGeometry = new THREE.SphereGeometry(1, 24, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: planet.material.color.getHex(),
                    transparent: true,
                    opacity: 0.2,
                    wireframe: true,
                    wireframeLinewidth: 2
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(planet.position);
                scene.add(sphere);
                
                planet.userData.influenceSphere = sphere;
            }
            
            // Ensure radius is never smaller than base radius
            const finalRadius = Math.max(planet.userData.baseRadius, radius);
            
            // Update the sphere's scale
            const sphere = planet.userData.influenceSphere;
            sphere.scale.set(finalRadius, finalRadius, finalRadius);
            
            // Update sphere color
            sphere.material.color.copy(planet.material.color);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // required if controls.enableDamping = true
            
            // Animate civilization planets (pulsing effect)
            const time = Date.now() * 0.001; // Current time in seconds
            
            for (let planet of civilizationPlanets) {
                const userData = planet.userData;
                if (userData) {
                    // Calculate pulse effect
                    const pulse = 0.2 * Math.sin(time * userData.pulseSpeed + userData.pulsePhase) + 1;
                    planet.scale.set(pulse, pulse, pulse);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Add this function to update the metrics display
        function updateMetricsDisplay() {
            // Update Earth encounters
            document.getElementById('earth-encounters').textContent = earthEncounters;
            
            // Find the civilization with most unique conquests
            let maxConquests = 0;
            let topConqueror = 'None';
            let topConquerorColor = '#FFFFFF';
            let topConquerorId = '';
            let topConquerorAggression = 0;
            let topConquerorTech = 0;
            
            civilizationConquests.forEach((data, id) => {
                const uniqueConquests = data.conqueredCivs.size;
                if (uniqueConquests > maxConquests) {
                    maxConquests = uniqueConquests;
                    topConquerorId = id;
                    // Find the civilization's index
                    const civIndex = civilizationPlanets.findIndex(c => c.userData.civilizationId === id);
                    topConqueror = `Civ_${civIndex + 1}`; // Adding 1 to make it 1-based instead of 0-based
                    topConquerorColor = data.color;
                    // Find the civilization's scores
                    const civ = civilizationPlanets[civIndex];
                    if (civ) {
                        topConquerorAggression = civ.userData.aggressivenessFactor.toFixed(2);
                        topConquerorTech = civ.userData.techAdvancementRate.toFixed(2);
                    }
                }
            });
            
            // Update display to show number of unique civilizations conquered
            const topConquerorElement = document.getElementById('top-conqueror');
            if (maxConquests > 0) {
                topConquerorElement.style.color = topConquerorColor;
                topConquerorElement.textContent = `${topConqueror} (Aggr: ${topConquerorAggression}, Tech: ${topConquerorTech}) has conquered ${maxConquests} civilizations`;
            } else {
                topConquerorElement.style.color = '#FFFFFF';
                topConquerorElement.textContent = 'No conquests yet';
            }
        }
        
        // Start the visualization
        init();
    </script>
</body>
</html>
