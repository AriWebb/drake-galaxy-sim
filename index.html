<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milky Way Galaxy Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            display: block;
            user-select: none;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
        }
        
        p {
            margin: 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Milky Way Galaxy Visualization</h1>
        <p>Use mouse to rotate, scroll to zoom, and right-click drag to pan</p>
        <button id="focusEarth">Focus on Earth</button>
        <button id="focusGalaxy">View Entire Galaxy</button>
    </div>
    
    <div id="drake-equation">
        <h2>Drake Equation Calculator</h2>
        <p>Adjust parameters to calculate potential civilizations in our galaxy</p>
        
        <div class="slider-container">
            <label for="R">R* = Average rate of star formation (stars/year)</label>
            <input type="range" id="R" min="1" max="20" value="7" step="0.1">
            <span id="R-value">7</span>
        </div>
        
        <div class="slider-container">
            <label for="fp">fp = Fraction of stars with planets</label>
            <input type="range" id="fp" min="0" max="1" value="0.5" step="0.01">
            <span id="fp-value">0.5</span>
        </div>
        
        <div class="slider-container">
            <label for="ne">ne = Average habitable planets per star</label>
            <input type="range" id="ne" min="0" max="5" value="2" step="0.1">
            <span id="ne-value">2</span>
        </div>
        
        <div class="slider-container">
            <label for="fl">fl = Fraction of habitable planets with life</label>
            <input type="range" id="fl" min="0" max="1" value="0.33" step="0.01">
            <span id="fl-value">0.33</span>
        </div>
        
        <div class="slider-container">
            <label for="fi">fi = Fraction of life that develops intelligence</label>
            <input type="range" id="fi" min="0" max="1" value="0.1" step="0.01">
            <span id="fi-value">0.1</span>
        </div>
        
        <div class="slider-container">
            <label for="fc">fc = Fraction of intelligence that develops detectable technology</label>
            <input type="range" id="fc" min="0" max="1" value="0.1" step="0.01">
            <span id="fc-value">0.1</span>
        </div>
        
        <div class="slider-container">
            <label for="L">L = Longevity of detectable civilizations (years)</label>
            <input type="range" id="L" min="1" max="10000" value="1000" step="1">
            <span id="L-value">1000</span>
        </div>
        
        <div id="result">
            <p>N = <span id="N-value">0</span> civilizations in our galaxy</p>
        </div>
        
        <button id="generate-planets">Generate Civilizations</button>
    </div>
    
    <style>
        button {
            background-color: #0077ff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 5px 5px 0 0;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0055cc;
        }
        
        #drake-equation {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
            font-family: Arial, sans-serif;
        }
        
        h2 {
            margin-top: 0;
            font-size: 1.2em;
        }
        
        .slider-container {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 80%;
            margin-right: 10px;
        }
        
        #result {
            margin: 15px 0;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        #generate-planets {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            font-size: 1em;
            background-color: #4CAF50;
        }
        
        #generate-planets:hover {
            background-color: #388E3C;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Galaxy visualization
        let scene, camera, renderer, controls;
        const particleCount = 10000;
        const galaxyRadius = 5000;
        const galaxyHeight = 300;
        const coreRadius = 1000;
        const coreConcentration = 0.5;
        
        // Variables to store Earth's position
        let earthX, earthY, earthZ;
        
        // Variables for Drake Equation
        let civilizationPlanets = [];
        let drakeN = 0;
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(0, 1000, 2000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Add controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 100;
            controls.maxDistance = 15000;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            
            // Create stars
            createGalaxy();
            
            // Add window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Add button handlers
            document.getElementById('focusEarth').addEventListener('click', focusOnEarth);
            document.getElementById('focusGalaxy').addEventListener('click', focusOnGalaxy);
            document.getElementById('generate-planets').addEventListener('click', generateCivilizations);
            
            // Add Drake equation slider handlers
            setupDrakeEquation();
            
            // Start animation loop
            animate();
        }
        
        // Setup Drake Equation sliders and calculation
        function setupDrakeEquation() {
            // Get all sliders
            const sliders = ['R', 'fp', 'ne', 'fl', 'fi', 'fc', 'L'];
            
            // Add event listeners to update values and recalculate N
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(`${id}-value`);
                
                // Set initial value
                valueSpan.textContent = slider.value;
                
                // Add change event listener
                slider.addEventListener('input', function() {
                    valueSpan.textContent = this.value;
                    calculateDrakeEquation();
                });
            });
            
            // Initial calculation
            calculateDrakeEquation();
        }
        
        // Calculate Drake Equation: N = R* × fp × ne × fl × fi × fc × L
        function calculateDrakeEquation() {
            const R = parseFloat(document.getElementById('R').value);
            const fp = parseFloat(document.getElementById('fp').value);
            const ne = parseFloat(document.getElementById('ne').value);
            const fl = parseFloat(document.getElementById('fl').value);
            const fi = parseFloat(document.getElementById('fi').value);
            const fc = parseFloat(document.getElementById('fc').value);
            const L = parseFloat(document.getElementById('L').value);
            
            // Calculate N
            drakeN = R * fp * ne * fl * fi * fc * L;
            
            // Update display
            document.getElementById('N-value').textContent = Math.round(drakeN);
        }
        
        // Generate civilizations based on Drake equation result
        function generateCivilizations() {
            // Remove any existing civilization planets
            removeCivilizations();
            
            // Calculate how many planets to generate
            let numPlanets = Math.round(drakeN);
            
            // Cap the number of planets to avoid performance issues
            const maxPlanets = 1000;
            const scaleFactor = numPlanets > maxPlanets ? numPlanets / maxPlanets : 1;
            numPlanets = Math.min(numPlanets, maxPlanets);
            
            if (numPlanets <= 0) {
                alert('Based on current parameters, there are no detectable civilizations in the galaxy.');
                return;
            }
            
            // Create a group for civilization planets
            const civilizationsGroup = new THREE.Group();
            civilizationsGroup.userData = { isCivilizationsGroup: true };
            scene.add(civilizationsGroup);
            
            // Generate random planets throughout the galaxy
            for (let i = 0; i < numPlanets; i++) {
                // Determine if planet is in core or in spiral arms (similar logic as stars)
                const isCore = Math.random() < 0.1; // Less likely in core
                
                let x, y, z;
                
                if (isCore) {
                    // Planets in galactic core
                    const r = Math.random() * coreRadius * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 0.3 * Math.PI;
                    
                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);
                } else {
                    // Planets in spiral arms
                    const arm = Math.floor(Math.random() * 5); // 5 spiral arms
                    const angle = (Math.PI * 2 * arm / 5) + (Math.random() * 0.5);
                    const distance = coreRadius + Math.random() * (galaxyRadius - coreRadius) * 0.9;
                    const spiralFactor = 4.0;
                    
                    const theta = angle + (distance / galaxyRadius) * spiralFactor;
                    
                    x = distance * Math.cos(theta);
                    z = distance * Math.sin(theta);
                    
                    // Add some randomness to spiral
                    x += (Math.random() - 0.5) * distance * 0.2;
                    z += (Math.random() - 0.5) * distance * 0.2;
                    
                    // Y-position (height) drops off with distance from center
                    const heightFactor = 1 - (distance / galaxyRadius) * 0.8;
                    y = (Math.random() - 0.5) * galaxyHeight * heightFactor * 0.5;
                }
                
                // Create the planet
                const planetGeometry = new THREE.SphereGeometry(15 + Math.random() * 15, 16, 16);
                
                // Choose a fully random color for each civilization
                const hue = Math.random(); // Random hue across the full spectrum
                const saturation = 0.7 + Math.random() * 0.3; // High saturation
                const lightness = 0.4 + Math.random() * 0.3; // Medium to bright
                const planetColor = new THREE.Color().setHSL(hue, saturation, lightness);
                
                const planetMaterial = new THREE.MeshBasicMaterial({
                    color: planetColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(x, y, z);
                
                // Add a pulsing effect to make civilizations noticeable
                planet.userData = {
                    initialScale: 1,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 0.5
                };
                
                civilizationsGroup.add(planet);
                civilizationPlanets.push(planet);
            }
            
            // Update info about scaling
            if (scaleFactor > 1) {
                alert(`Showing ${numPlanets} of approximately ${Math.round(drakeN)} civilizations to maintain performance.`);
            }
        }
        
        // Remove all civilization planets
        function removeCivilizations() {
            // Remove each planet from its parent and dispose resources
            for (let planet of civilizationPlanets) {
                if (planet.parent) planet.parent.remove(planet);
                if (planet.geometry) planet.geometry.dispose();
                if (planet.material) planet.material.dispose();
            }
            
            // Find and remove any civilization groups from the scene
            scene.children.forEach(child => {
                if (child.isGroup && child.userData && child.userData.isCivilizationsGroup) {
                    scene.remove(child);
                }
            });
            
            // Clear the array
            civilizationPlanets = [];
        }
        
        // Function to focus camera on Earth
        function focusOnEarth() {
            // Create a position slightly offset from Earth for better viewing
            const offset = new THREE.Vector3(earthX, earthY + 50, earthZ + 200);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3();
            controls.target.copy(startTarget);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, offset, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(earthX, earthY, earthZ), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Function to focus on the entire galaxy
        function focusOnGalaxy() {
            // Create a position to view the entire galaxy
            const galaxyViewPosition = new THREE.Vector3(0, 1000, 5000);
            
            // Animate the camera move
            const startPosition = new THREE.Vector3().copy(camera.position);
            const startTarget = new THREE.Vector3().copy(controls.target);
            
            const duration = 1000; // ms
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeOutQuad(progress);
                
                // Interpolate camera position
                camera.position.lerpVectors(startPosition, galaxyViewPosition, easeProgress);
                
                // Interpolate controls target (what the camera is looking at)
                const newTarget = new THREE.Vector3();
                newTarget.lerpVectors(startTarget, new THREE.Vector3(0, 0, 0), easeProgress);
                controls.target.copy(newTarget);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            // Start animation
            animateCamera();
        }
        
        // Easing function for smoother camera animation
        function easeOutQuad(t) {
            return t * (2 - t);
        }
        
        // Create the galaxy with spiral arms
        function createGalaxy() {
            const starColors = [
                0xFFFFFF, // white
                0xFFFF00, // yellow
                0xFFD700, // gold
                0xFF8C00, // orange
                0xFF4500, // red-orange
                0x00BFFF, // light blue
                0x1E90FF  // blue
            ];
            
            // Create geometry for all stars
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const color = new THREE.Color();
            
            // Define spiral arms
            const spiralArms = 5;
            const armSpread = 0.5;
            
            // Earth's position in the Milky Way
            // Solar system is about 26,000 light years (8 kpc) from the galactic center
            // We'll place it in one of the spiral arms
            const earthArmIndex = 2; // Choosing the 3rd arm (0-indexed)
            const earthDistanceFromCenter = 2600; // Scaled distance
            const earthSpiralFactor = 4.0;
            const earthAngle = (Math.PI * 2 * earthArmIndex / spiralArms) + 0.2; // Adding a bit of offset
            const earthTheta = earthAngle + (earthDistanceFromCenter / galaxyRadius) * earthSpiralFactor;
            
            // Calculate Earth's position (assign to global variables)
            earthX = earthDistanceFromCenter * Math.cos(earthTheta);
            earthZ = earthDistanceFromCenter * Math.sin(earthTheta);
            earthY = 0; // Roughly on the galactic plane
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Determine if star is in core or in spiral arms
                const isCore = Math.random() < coreConcentration;
                
                let x, y, z;
                
                if (isCore) {
                    // Stars in galactic core - dense center
                    const r = Math.random() * coreRadius;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * 0.5 * Math.PI;
                    
                    x = r * Math.cos(theta) * Math.cos(phi);
                    y = r * Math.sin(phi);
                    z = r * Math.sin(theta) * Math.cos(phi);
                    
                    // Core stars are whiter/bluer
                    color.set(starColors[Math.floor(Math.random() * 2)]);
                } else {
                    // Stars in spiral arms
                    const arm = Math.floor(Math.random() * spiralArms);
                    const angle = (Math.PI * 2 * arm / spiralArms) + (Math.random() * armSpread);
                    const distance = coreRadius + Math.random() * (galaxyRadius - coreRadius);
                    const spiralFactor = 4.0; // controls tightness of the spiral
                    
                    const theta = angle + (distance / galaxyRadius) * spiralFactor;
                    
                    x = distance * Math.cos(theta);
                    z = distance * Math.sin(theta);
                    
                    // Add some randomness to spiral
                    x += (Math.random() - 0.5) * distance * 0.3;
                    z += (Math.random() - 0.5) * distance * 0.3;
                    
                    // Y-position (height) drops off with distance from center
                    const heightFactor = 1 - (distance / galaxyRadius) * 0.8;
                    y = (Math.random() - 0.5) * galaxyHeight * heightFactor;
                    
                    // Different colors based on position
                    const colorIndex = Math.min(Math.floor((distance / galaxyRadius) * starColors.length), starColors.length - 1);
                    color.set(starColors[colorIndex]);
                }
                
                // Set position
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                // Set color
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            // Add attributes to geometry
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create point material
            const material = new THREE.PointsMaterial({
                size: 4,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            // Create the particle system
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Add a reference point for the galactic center
            const centerGeometry = new THREE.SphereGeometry(50, 32, 32);
            const centerMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            scene.add(centerSphere);
            
            // Add Earth (Solar System)
            const earthGeometry = new THREE.SphereGeometry(30, 32, 32);
            const earthMaterial = new THREE.MeshBasicMaterial({
                color: 0x0077ff, // Blue
                transparent: true,
                opacity: 0.9
            });
            const earthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
            earthSphere.position.set(earthX, earthY, earthZ);
            scene.add(earthSphere);
            
            // Add a label for Earth
            createEarthLabel(earthX, earthY, earthZ);
            
            // Add a helper line to Earth from the center
            const earthLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(earthX, earthY, earthZ)
            ]);
            const earthLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0088ff,
                transparent: true,
                opacity: 0.5
            });
            const earthLine = new THREE.Line(earthLineGeometry, earthLineMaterial);
            scene.add(earthLine);
        }
        
        // Function to create a text label for Earth
        function createEarthLabel(x, y, z) {
            // Create a div for the label
            const earthLabelDiv = document.createElement('div');
            earthLabelDiv.className = 'label';
            earthLabelDiv.textContent = 'Earth';
            earthLabelDiv.style.color = '#ffffff';
            earthLabelDiv.style.position = 'absolute';
            earthLabelDiv.style.backgroundColor = 'rgba(0,0,0,0.6)';
            earthLabelDiv.style.padding = '2px 6px';
            earthLabelDiv.style.borderRadius = '3px';
            earthLabelDiv.style.pointerEvents = 'none';
            earthLabelDiv.style.zIndex = '10';
            document.body.appendChild(earthLabelDiv);
            
            // Update the label position in the animation loop
            const earthPosition = new THREE.Vector3(x, y, z);
            const earthVector = new THREE.Vector3();
            
            // Add to the animation function to update position
            const originalAnimate = animate;
            animate = function() {
                // Call the original animate function
                originalAnimate();
                
                // Update label position
                earthVector.copy(earthPosition);
                earthVector.project(camera);
                
                const x = (earthVector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(earthVector.y * 0.5) + 0.5) * window.innerHeight;
                
                earthLabelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                
                // Hide label if Earth is behind the camera
                if (earthVector.z > 1) {
                    earthLabelDiv.style.display = 'none';
                } else {
                    earthLabelDiv.style.display = 'block';
                }
            };
        }
        
        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // required if controls.enableDamping = true
            
            // Animate civilization planets (pulsing effect)
            const time = Date.now() * 0.001; // Current time in seconds
            
            for (let planet of civilizationPlanets) {
                const userData = planet.userData;
                if (userData) {
                    // Calculate pulse effect
                    const pulse = 0.2 * Math.sin(time * userData.pulseSpeed + userData.pulsePhase) + 1;
                    planet.scale.set(pulse, pulse, pulse);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Start the visualization
        init();
    </script>
</body>
</html>